<!doctype html>
<html>
	<head>
		<title>learningthree.js boiler plate for three.js</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
			
		<script src="js/vendor/three.js/Three.js"></script>
		<script src="js/vendor/three.js/Detector.js"></script>
		<!-- https://github.com/mrdoob/stats.js -->
		<script src="js/vendor/three.js/Stats.js"></script>
        <script src="js/vendor/ShaderExtras.js"></script>

        <script src="js/vendor/RenderPass.js"></script>
        <script src="js/vendor/BloomPass.js"></script>
        <script src="js/vendor/ShaderPass.js"></script>
        <script src="js/vendor/EffectComposer.js"></script>
        <script src="js/vendor/DotScreenPass.js"></script>
        <script src="js/vendor/MaskPass.js"></script>

		<script src="js/vendor/threex/THREEx.screenshot.js"></script>
		<script src="js/vendor/threex/THREEx.FullScreen.js"></script>
		<script src="js/vendor/threex/THREEx.WindowResize.js"></script>
        <script src="js/vendor/threex/THREEx.KeyboardState.js"></script>
        <script src="js/vendor/threex.dragpancontrols.js"></script>

		<link  href="css/main.css" rel="stylesheet"/>
	</head>
<body>
<!-- three.js container -->
<div id="container"></div>
<!-- info on screen display -->
<div id="info">
    <div class="top">
        <a href="http://learningthreejs.com/blog/2011/12/20/boilerplate-for-three-js/" target="_blank">LearningThree.js</a>
        boiler plate for
        <a href="https://github.com/mrdoob/three.js/" target="_blank">three.js</a>
    </div>
    <div class="bottom" id="inlineDoc" >
        - <i>p</i> for screenshot
    </div>
</div>

<script type="text/javascript">
    var stats, scene, renderer;
    var camera, keyboard;
    var car;


    if( !init() )	animate();

    // init the scene
    function buildRenderer() {      
        if (Detector.webgl) {
            renderer = new THREE.WebGLRenderer({
                antialias: true,	// to get smoother output
                preserveDrawingBuffer: true	// to allow screenshot
            });
            renderer.setClearColorHex(0xFFFFFF, 1);
            // uncomment if webgl is required
            //}else{
            //	Detector.addGetWebGLMessage();
            //	return true;
        } else {
            renderer = new THREE.CanvasRenderer();
        }
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function createCameraControl() {
//cameraControls	= new THREEx.DragPanControls(camera)
        keyboard = new THREEx.KeyboardState();

        // transparently support window resize
        THREEx.WindowResize.bind(renderer, camera);
        // allow 'p' to make screenshot
        THREEx.Screenshot.bindKey(renderer);
        // allow 'f' to go fullscreen where this feature is supported
        if (THREEx.FullScreen.available()) {
            THREEx.FullScreen.bindKey();
            document.getElementById('inlineDoc').innerHTML += "- <i>f</i> for fullscreen";
        }
    }
    function addSky() {
//load sky images
        var urls = [
            "images/sky1.png",
            "images/sky1.png",
            "images/sky1.png",
            "images/sky1.png",
            "images/sky1.png",
            "images/sky1.png"
        ];
        var textureCube = THREE.ImageUtils.loadTextureCube(urls);

        //setup the cube shader
        var shader = THREE.ShaderUtils.lib["cube"];
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        uniforms['tCube'].texture = textureCube;
        var material = new THREE.ShaderMaterial({
            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: uniforms
        });
        return material;
    }
    function buildGround() {
        var grassTex = THREE.ImageUtils.loadTexture('images/grass.png');
        grassTex.wrapS = THREE.RepeatWrapping;
        grassTex.wrapT = THREE.RepeatWrapping;
        grassTex.repeat.x = 256;
        grassTex.repeat.y = 256;
        //var groundMat = new THREE.MeshBasicMaterial({color:0xFF66FF});
        var groundMat = new THREE.MeshBasicMaterial({map: grassTex});

        var groundGeo = new THREE.PlaneGeometry(400, 400);
        var ground = new THREE.Mesh(groundGeo, groundMat);
        ground.position.y = -1.9; //lower it
        ground.rotation.x = -Math.PI / 2; //-90 degrees around the xaxis
        //IMPORTANT, draw on both sides
        ground.doubleSided = true;
        return ground;
    }
    function init(){
        buildRenderer();
        document.getElementById('container').appendChild(renderer.domElement);


        // add Stats.js - https://github.com/mrdoob/stats.js
        stats = new Stats();
        stats.domElement.style.position	= 'absolute';
        stats.domElement.style.bottom	= '0px';
        document.body.appendChild( stats.domElement );

        // create a scene
        scene = new THREE.Scene();

        // put a camera in the scene
        camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 100000 ); //extend the camera out
        camera.position.set(0, 3, 120);
        scene.add(camera);

        // create a camera contol
        createCameraControl();

        // here you add your objects
        // - you will most likely replace this part by your own
        var geometry	= new THREE.TorusGeometry( 1, 0.42 );
        var material	= new THREE.MeshNormalMaterial();
        var mesh	= new THREE.Mesh( geometry, material );
        scene.add( mesh );
        //turn on shadows
        renderer.shadowMapEnabled = true;
        renderer.shadowMapSoft = true;


        //add skymap
        var material = addSky();
        //create a skybox
        var size = 10000;
        skyboxMesh = new THREE.Mesh(
                new THREE.CubeGeometry(size,size,size),material);
        //IMPORTANT!! draw on the inside instead of outside
        skyboxMesh.flipSided = true; // you must have this or you won't see anything
        scene.add(skyboxMesh);


        //add sunlight
        var light = new THREE.SpotLight();
        light.position.set(0,500,0);
        scene.add(light);

        //add ground
        var ground = buildGround();
        scene.add(ground);



        //load a car
        //IMPORTANT: be sure to use ./ or it may not load the .bin correctly
        new THREE.BinaryLoader().load('./obj/VeyronNoUv_bin.js', function(geometry) {
            var material	= new THREE.MeshNormalMaterial();
            var orange    = new THREE.MeshLambertMaterial( { color: 0x995500, opacity: 1.0, transparent: false } );
            var mesh	= new THREE.Mesh( geometry, orange );
            mesh.scale.x = mesh.scale.y = mesh.scale.z = 0.05;
            scene.add( mesh );
            car = mesh;
        });

    }


    var composer;
    var renderModel;
    var deltaRotation = 0.1;
    var deltaAngle = 0.1;

    // animation loop
    function animate() {

        // loop on request animation loop
        // - it has to be at the begining of the function
        // - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
       requestAnimationFrame( animate );

        // do the render

       // render();
        renderDelta();
        //car.rotation.y += 0.1;

        // update stats
      //  stats.update();

    }

    var angle = Math.PI/2;
    // render the scene
    function nextRotation() {
        return 0.1;
    }
    var angles = [0.0078,0,-0.0098,-0.0156,-0.0088,0.001,-0.0059,-0.0117,-0.0176,-0.0244,-0.0264,-0.0352,-0.0479]; //,-0.0557,-0.0449,-0.0459,-0.041,-0.0439,-0.0576,-0.0723,-0.0752,-0.0771,-0.0674,-0.0596,-0.0449,-0.0322,-0.0371,-0.04,-0.0303,-0.0225,-0.0186,-0.0156,-0.0176,-0.0234,-0.0205,-0.0068,0.0088,0.0244,0.0479,0.0664,0.0742,0.0977,0.1328,0.1885,0.209,0.2461,0.2744,0.3428,0.417,0.4971,0.6045,0.6738,0.7441,0.8398,0.9443,1.0234,1.0459,1.04,1.0156,0.9961,1.0029,1.0332,1.0488,1.0566,0.9922,0.8926,0.8203,0.7637,0.7217,0.6934,0.5527,0.3711,0.2051,0.0264,-0.0908,-0.2646,-0.46,-0.5723,-0.6074,-0.5801,-0.5605,-0.4355,-0.2842,-0.0029,0.1611,0.2822,0.3662,0.3877,0.4199,0.4824,0.541,0.5664,0.5605,0.5264,0.4697,0.4629,0.4707,0.4883,0.5127,0.5527,0.5674,0.5166,0.4961,0.4609,0.3857,0.3193,0.3701,0.4512,0.5488,0.5586,0.5547,0.5605,0.6045,0.6045,0.5381,0.4873,0.5225,0.5811,0.6064,0.583,0.5498,0.5068,0.498,0.4805,0.4326,0.3848,0.3506,0.2852,0.2275,0.1787,0.124,0.0732,0.0625,0.0518,0,-0.0127,-0.0107,0.0381,0.0859,0.084,0.1045,0.166,0.2061,0.2178,0.2305,0.2187,0.2744,0.3613,0.4365,0.4141,0.2871,0.2314,0.1553,0.207,0.2637,0.248,0.1572,0.0811,0.0107,0.0293,0.1797,0.499,0.7266,0.7686,0.6885,0.5703,0.5957,0.7314,0.7969,0.7188,0.6074,0.458,0.3145,0.2646,0.375,0.2129,0.2363,0.167,0.1895,0.2451,0.2275,0.21,0.1094,-0.001,-0.0449,-0.0371,0.0215,0.0313,-0.0068,-0.0273,-0.0586,-0.0391,-0.0273,0.0068,0.0293,0.0303,0.0078,-0.0332,-0.0254,0.0107,0.0459,0.041,0.0459,0.0322,0.0186,-0.0078,0.0107,0.0488,0.0605,0.0137,-0.0078,-0.0137,-0.0303,-0.0117,-0.002,0.002,0,-0.0146,-0.0303,-0.0117,-0.002,-0.0059,-0.0303,-0.041,-0.0596,-0.082,-0.0996,-0.1201,-0.0664,0.0664,0.1953,0.3066,0.3789,0.4434,0.5752,0.7949,1.1338,1.3828,1.5361,1.6426,1.792,1.8857,1.8291,1.668,1.4951,1.4229,1.3379,1.1621,0.9746,0.7764,0.5439,0.3818,0.2334,0.0762,-0.04,-0.0723,-0.0107,0.1172,0.2402,0.2744,0.1387,-0.0254,-0.1113,-0.0889,-0.0898,-0.2363,-0.3018,-0.4893,-0.5986,-0.4961,-0.2549,0.0381,0.249,0.2988,0.4189,0.5244,0.5879,0.5801,0.5176,0.4834,0.4727,0.5293,0.6387,0.7451,0.8066,0.8057,0.7959,0.7832,0.7666,0.7783,0.7793,0.7617,0.7354,0.6816,0.6123,0.5771,0.5752,0.5332,0.5059,0.4658,0.4229,0.3779,0.3447,0.3486,0.3594,0.3486,0.2949,0.2061,0.1426,0.1162,0.0557,0.0088,-0.0244,0.0137,0.0791,0.1338,0.0879,0.0098,-0.0244,-0.0166,0.0332,0.0449,0.04,0.0381,0.1172,0.2627,0.3359,0.3018,0.1934,0.0527,-0.04,0.1045,0.2861,0.4961,0.458,0.2813,0.0273,-0.0908,-0.0313,0.127,0.2617,0.2861,0.2764,0.2852,0.3379,0.4961,0.5078,0.4814,0.3623,0.2666,0.3057,0.4434,0.6211,0.6719,0.6221,0.4727,0.249,0.0996,0.0439,0.0293,0.0166,0.0225,0.0391,0.0283,0.001,-0.0127,-0.0156,-0.0186,-0.0293,-0.0332,-0.0674,-0.0742,-0.0664,-0.0674,-0.0459,-0.0488,-0.0508,-0.0762,-0.0576,-0.0322,-0.001,0.0342,0.0361,0.0176,-0.0059,-0.0137,0.0029,0.0352,0.084,0.0664,0.0391,0.0127,0.0166,-0.0059,0.0039,0.0166,0.0352,0.0449,0.0664,0.0811,0.0869,0.0928,0.1016,0.1025,0.1143,0.1152,0.1357,0.1729,0.2148,0.251,0.2266,0.2109,0.1992,0.1836,0.1885,0.3135,0.4883,0.7354,0.8936,0.9521,0.9727,1.166,1.6113,1.999,1.999,1.999,1.6504];
    var anglesIndex = 0;
    function nextAngle() {
        var returnVal = 0.0;

        if (anglesIndex >= angles.length) {
            console.log("aI: " + anglesIndex);
            anglesIndex = 0;
            console.log("Reset anglesIndex, index " + anglesIndex);
        }
        returnVal = angles[anglesIndex];
        console.log("retVal: " + returnVal + ", aI: " + anglesIndex);
        anglesIndex += 1;
        return returnVal;
    }
    function renderDelta() {

        //console.log("render");
        // update camera controls
        //cameraControls.update();
        /*
        if(keyboard.pressed("left")) {
            car.rotation.y += 0.1;
        }
        if(keyboard.pressed("right")) {
            car.rotation.y -= 0.1;
        }
        if(keyboard.pressed("up")) {
            car.position.z -= 1.0;
        }
        if(keyboard.pressed("down")) {
            car.position.z += 1.0;
        }
        */
        /*
        car.rotation.y += deltaRotation;
        angle += deltaAngle;
        car.position.z += Math.sin(-angle);
        car.position.x += Math.cos(-angle);
        */
        if (car) {
            console.log("car ok");
            var dR = nextRotation();
            car.rotation.y += dR;
            var dA = nextAngle();
            angle += dA;
            car.position.z -= Math.sin(-angle);
            car.position.x -= Math.cos(-angle);

        } else {
            console.log("car not init");
        }

        if(keyboard.pressed("left")) {
            car.rotation.y += 0.1;
            angle += 0.1;
        }
        if(keyboard.pressed("right")) {
            car.rotation.y -= 0.1;
            angle -= 0.1;
        }
        if(keyboard.pressed("up")) {
            car.position.z -= Math.sin(-angle);
            car.position.x -= Math.cos(-angle);
        }
        if(keyboard.pressed("down")) {
            car.position.z += Math.sin(-angle);
            car.position.x += Math.cos(-angle);
        }


        // actually render the scene
        renderer.render( scene, camera );
    }
</script>
</body>
</html>
